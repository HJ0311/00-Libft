# Libft
## 당신의 첫 번째 라이브러리
> 요약: 이 프로젝트는 C 라이브러리를 코딩해보는 것이 목적이다. 프로그램에서 유용하게 쓰일 범용 많은 범용 함수를 포함한다.
###### 버전: 16
---
### 목차

<div align="center">

| Chapter | Contents |
| :-----: | :------: |
| 1 | [서론](#Chapter-1) |
| 2 | [기본 지침](#Chapter-2) |
| 3 | [필수 파트](#Chapter-3) <br> &emsp; 3-1. [기술적 고려 사항](#Chapter-3-1) <br> &emsp; 3-2. [파트 1 - libc 함수들](#Chapter-3-2) <br> &emsp; 3-3. [파트 2 - 추가적인 함수들](#Chapter-3-3) |
| 4 | [보너스 파트](#Chapter-4) |

</div>

---
## Chapter 1
### 서론

C 프로그래밍은 매우 유용한 표준 함수에 접근할 수 없게 되면 꽤 지루한 작업이 될 것이다.
이 프로젝트는 표준 함수들이 어떻게 작동하는지 이해하고, 사용하는 법과 구현하는 법을 배우는 것이 목적이다. 자신만의 라이브러리를 만들게 될 것이다. C 학교 과제에서 사용할 것이므로 매우 유용할 것이다.
<br><br>
1년 내내 **libft**를 확장하는 시간을 가져라. 하지만, 새 프로젝트를 진행할 때는 라이브러리에서 사용되는 함수가 프로젝트 지침에 허용되는지 확인해라.

---
## Chapter 2
### 기본 지침

- 프로젝트는 C로 작성 되어야 한다.
- 프로젝트는 Norm을 만족하며 작성 되어야 한다. 만약 보너스 파일/함수가 있다면, Norm 확인을 해야 하며 norm 에러가 발생할 경우 0점을 받게 된다.
- 함수는 정의되지 않은 동작을 제외하고 예기치 못하게 종료(세그먼테이션 폴트, bus 오류, 이중 free 등등) 되어선 안 된다. 만약 그런 상황이 발생 된다면, 프로젝트는 기능하지 않는 것으로 판단하며 평가 도중 0점을 받게 될 것이다.
- 힙의 할당된 모든 메모리 공간은 적절히 해제 되어야 한다. 어떤 leak도 허용될 수 없다.
- 과제가 요구 한다면, 소스 파일들을 **-Wall -Wextra -Werror** 플래그와 cc 컴파일러를 사용하여 컴파일 해주는 **Makefile**을 제출해야 하며 Makefile은 리링크 되어선 안 된다.
- Makefile은 **$(NAME), all, clean, fclean, 그리고 re** 규칙을 포함해야 한다.
- 프로젝트에 bonus를 포함할 거라면 Makefile에 **bonus** 규칙을 포함 시켜야 하며 프로젝트의 메인 파트에서 금지된 다양한 헤더들, 라이브러리들 또는 함수들 모두를 추가 해야 한다. 보너스는 과제에서 따로 명시해놓지 않았다면 _bonus.{c/h} 파일에 있어야 한다. 필수 파트와 보너스 파트 평가는 별개로 이루어진다.
- 만약 프로젝트가 **libft**를 사용하는 것을 허용 했다면 소스 파일과 관련 **Makefile**을 **libft** 폴더에 복사해야 한다. 프로젝트의 **Makefile**은 반드시 자신의 **Makefile**을 사용하여 라이브러리를 컴파일 해야 하며, 그 다음 프로젝트를 컴파일 해야 한다.
- 제출할 필요 없고 평가 받을 필요 없지만 프로젝트를 위해서 테스트 프로그램을 만드는 것을 권장한다. 당신과 동료들이 쉽게 테스트 할 수 있는 기회를 줄 것이다. 특히 평가 방어 중에 유용하다는 것을 깨닫게 될 것이다. 실제로 평가 방어 도중 평가 중인 동료나 자신의 테스트를 사용해도 좋다.
- 할당된 git 저장소에 작업물을 제출해라. git 저장소에 있는 작업물만 평가 받을 수 있다. Deppthought은 심층 평가 이후 당신의 작업물을 평가할 것이다. 만약 Deppthought의 평가 중 오류가 발생한다면, 평가는 종료될 것이다.

---
## Chapter 3
### 필수 파트

<div align="center">

| **프로그램 명** | libft.a |
| :--------------: | :-----: |
| **제출해야 하는 파일들** | Makefile, libft.h, ft_*.c |
| **Makefile** | NAME, all, clean, fclean, re |
| **외부 함수 사용** | 세부사항은 아래에 있음 |
| **Libft 허용** | 불허용 |
| **설명** | 라이브러리를 작성해라: 교육 과정 내내 유용한 도구가 될 함수의 집합 |

</div>

### Chapter 3-1
#### 기술적 고려 사항

- 전역 변수 정의는 금지된다.
- 더 복잡하게 함수를 쪼개기 위해 보조 함수가 필요하다면, static 함수를 정의해라. 이 함수는 해당 파일 내부에서만 유효하다.
- 저장소의 루트에 모든 파일을 배치해라.
- 사용하지 않는 파일을 제출하는 것은 금지된다.
- 모든 **.c** 파일들은 **-Wall -Wextra -Werror** 플래그와 함께 컴파일 되어야 한다.
- 라이브러리를 생성할 때 **ar** 명령어를 사용해야 한다. **libtool** 명령어는 금지된다.
- **libft.a**는 저장소의 루트에서 생성되어야 한다.

### Chapter 3-2
#### 파트 1 - Libc 함수들

일단, **libc**의 함수 집합을 재구현 해야 한다. 함수들은 원형과 동일한 프로토타입을 가지며 동일한 행동을 하도록 구현되어야 한다. **man**에 정의된 방식을 따라야 한다. 유일한 차이점은 이름 뿐이다. **`ft_`**라는 접두사로 시작해야 한다. 예를 들어, **strlen**은 **ft_strlen**이 된다.

> ⚠️
>
> 일부 함수 프로토타입은 'restrict' 수식어를 사용하여 재정의 해야 한다. 이 키워드는 c99 표준의 일부이다. 당신의 프로토 타입에 포함시키고 -std=c99 플래그로 컴파일 하는 금지된다.

원본 함수처럼 자신의 함수를 구현해야 한다. 외부 함수는 요구되지 않는다:

- **isalpha**
- **isdigit**
- **isalnum**
- **isascii**
- **isprint**
- **strlen**
- **memset**
- **bzero**
- **memcpy**
- **memmove**
- **strlcpy**
- **strlcat**
- **toupper**
- **tolower**
- **strchr**
- **strrchr**
- **strncmp**
- **memchr**
- **memcmp**
- **strnstr**
- **atoi**

아래의 두 개의 함수를 구현하기 위해, **malloc()**을 사용해야 한다:

- **calloc**
- **strdup**

### Chapter 3-3
#### 파트 2 - 추가적인 함수들

두 번째 파트에서는 **libc**에 속하지 않거나 그 일부이지만 다른 형태의 함수 집합을 구현해야 한다.

> ⚠️
>
> 다음 함수 중 일부는 파트 1의 함수들을 작성하는 데 유용할 것이다.

<br>

<div align="center">

| **함수 명** | ft_substr |
| :--------------: | :-----: |
| **프로토타입** | char *ft_substr(char const *s, unsigned int start, size_t len); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | s: 하위 문자열을 생성할 문자열.<br>start: 문자열 's'의 하위 문자열의 시작 인덱스<br>len: 하위 문자열의 최대 길이 |
| **반환값** | 하위 문자열.<br>할당에 실패하면 NULL. |
| **외부 함수 사용** | malloc |
| **설명** | 문자열 's'의 하위 문자열을 할당(malloc(3)을 사용하여)하고 반환한다.<br>하위 문자열은 'start' 인덱스부터 시작하고 'len'의 최대 길이를 갖는다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_strjoin |
| :--------------: | :-----: |
| **프로토타입** | char *ft_strjoin(char const *s1, char const *s2); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | s1: 접두사 문자열.<br>s2: 접미사 문자열. |
| **반환값** | 새로운 문자열.<br>할당에 실패하면 NULL.|
| **외부 함수 사용** | malloc |
| **설명** | 's1'와 's2'를 이은 새로운 문자열을 할당(malloc(3)을 사용하여)하고 반환한다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_strtrim |
| :--------------: | :-----: |
| **프로토타입** | char *ft_strtrim(char const *s1, char const *set); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | s1: 다듬을 문자열.<br>set: 참조하여 다듬을 문자 집합. |
| **반환값** | 다듬어진 문자열.<br>할당에 실패하면 NULL. |
| **외부 함수 사용** | malloc |
| **설명** | 문자열의 시작과 끝에서 'set'에 지정되어 있는 문자가 제거된 's1'의 복사복을 할당(malloc(3)을 사용하여)하고 반환한다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_split |
| :--------------: | :-----: |
| **프로토타입** | char **ft_split(char const *s, char c); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | s: 분할할 문자열.<br>c: 구분 문자. |
| **반환값** | 분할할 문자열들의 배열.<br>할당에 실패하면 NULL. |
| **외부 함수 사용** | malloc, free |
| **설명** | 구분 문자인 'c'를 사용해 문자열 's'를 분할하여얻은 문자열들의 배열을 할당(malloc(3)을 사용하여)하고 반환한다. 배열은 반드시 NULL 포인터로 끝나야 한다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_itoa |
| :--------------: | :-----: |
| **프로토타입** | char *ft_itoa(int n); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | n: 변환할 정수. |
| **반환값** | 정수를 나타내는 문자열.<br>할당에 실패하면 NULL. |
| **외부 함수 사용** | malloc |
| **설명** | 인자로 받은 정수를 나타내는 문자열을 할당(malloc(3)을 사용하여)하고 반환한다.<br>정수도 다뤄야 한다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_strmapi |
| :--------------: | :-----: |
| **프로토타입** | char *ft_strmapi(char const *s, char (*f)(unsigned int, char)); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | s: 반복할 문자열.<br>f: 각 문자에 적용될 함수. |
| **반환값** | 'f'가 성공적으로 적용되어 만들어진 문자열.<br>할당에 실패하면 NULL. |
| **외부 함수 사용** | malloc |
| **설명** | 문자열 's'의 각 문자열에 'f' 함수를 적용하고 그 인덱스를 첫 번째 인자로 전달하여 'f'가 성공적으로 적용된 결과로 새 문자열(malloc(3)을 사용하여)을 생성한다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_striteri |
| :--------------: | :-----: |
| **프로토타입** | void ft_striteri(char *s, void (*f)(unsgined int, char*)); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | s: 반복할 문자열.<br>f: 각 문자에 적용될 함수. |
| **반환값** | 없음 |
| **외부 함수 사용** | 없음 |
| **설명** | 인자로 전달된 문자열의 각 문자에 'f' 함수를 적용하고, 그 인덱스를 첫 번째 인자로 전달한다. 각 문자는 'f'로 전달되어 필요한 경우 수정된다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_putchar_fd |
| :--------------: | :-----: |
| **프로토타입** | void ft_putchar_fd(char c, int fd); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | c: 출력할 문자열.<br>fd: 작성할 파일 기술자. |
| **반환값** | 없음 |
| **외부 함수 사용** | write |
| **설명** | 주어진 파일 기술자로 문자 'c'를 출력한다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_putstr_fd |
| :--------------: | :-----: |
| **프로토타입** | void ft_putstr_fd(char *s, int fd); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | s: 출력할 문자열.<br>fd: 작성할 파일 기술자. |
| **반환값** | 없음 |
| **외부 함수 사용** | write |
| **설명** | 주어진 파일 기술자로 문자열 's'를 출력한다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_putendl_fd |
| :--------------: | :-----: |
| **프로토타입** | void ft_putendl_fd(char *s, int fd); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | s: 출력할 문자열.<br>fd: 작성할 파일 기술자. |
| **반환값** | 없음 |
| **외부 함수 사용** | write |
| **설명** | 주어진 파일 기술자로 문자열 's'를 출력하고 개행을 추가한다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_putnbr_fd |
| :--------------: | :-----: |
| **프로토타입** | void ft_putnbr_fd(int n, int fd); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | n: 출력할 정수.<br>fd: 작성할 파일 기술자. |
| **반환 값** | 없음 |
| **외부 함수 사용** | write |
| **설명** | 주어진 파일 기술자로 정수 'n'을 출력한다. |

</div>
<br>

---

## Chapter 4
### 보너스 파트

만약 필수 파트를 완료했다면 망설이지 말고 더 나아가라. 성공적으로 통과하게 되면 보너스 포인트를 얻게 될 것이다.
<br><br>
메모리와 문자열을 다루는 함수는 매우 유용하다. 하지만 리스트를 다루는 것은 더욱 유용하다는 것을 알게 될 것이다.
<br><br>
리스트의 노드를 나타내기 위해 다음과 같은 구조체를 사용해라. **libft.h** 파일에 그에 대한 정의를 추가해라:
<br>
<img width="509" alt="Screen Shot 2025-02-17 at 2 17 09 PM" src="https://github.com/user-attachments/assets/6cf92900-a4c7-4845-90ac-29bf08d32ac4" />
<br>
**t_list** 구조체의 멤버:

- **content**: 노드에 포함된 데이터. **void \***로 어떤 종류의 데이터든 담을 수 있다.

- **next**: 다음 노드의 주소. 마지막 노드라면 NULL이다.

**libft.a**에 보너스 함수를 추가하기 위해 Makefile에 **make bonus** 규칙을 추가해라.

> ⚠️
>
> 보너스 파트는 필수 파트가 완벽할 때만 접근할 수 있다. 완벽의 의미란 필수 파트를 완벽하게 수행하고 오작동 없이 작동함을 의미한다. 만약 필수 요구사항을 전부 통과하지 못 했다면, 보너스 파트는 절대 평가될 수 없다.

<br>
리스트를 쉽게 사용하기 위해 다음과 같은 함수를 구현해라.

<div align="center">

| **함수 명** | ft_lstnew |
| :--------------: | :-----: |
| **프로토타입** | t_list *ft_lstnew(void *content); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | content: 생성할 노드의 내용. |
| **반환값** | 새 노드 |
| **외부 함수 사용** | malloc |
| **설명** | 새 노드를 할당(malloc(3)을 사용하여)하고 반환한다. 멤버 변수 'content'는 'content' 매개 변수의 값으로 초기화 된다. 'next' 변수는 NULL로 초기화 된다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_lstadd_front |
| :--------------: | :-----: |
| **프로토타입** | void ft_lstadd_front(t_list **lst, t_list *new); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | lst: 리스트의 첫 번째 링크의 포인터 주소.<br>new: 리스트에 추가할 노드의 포인터 주소.  |
| **반환값** | 없음 |
| **외부 함수 사용** | 없음 |
| **설명** | 리스트의 시작 부분에 'new' 노드를 추가한다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_lstsize |
| :--------------: | :-----: |
| **프로토타입** | int ft_lstsize(t_list *lst); |
| **제출해야 하는 파일들** | - |
| **매개 변수s** | lst: 리스트의 시작 노드. |
| **반환값** | 리스트의 길이. |
| **외부 함수 사용** | 없음 |
| **설명** | 리스트의 노드 개수를 센다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_lstlast |
| :--------------: | :-----: |
| **프로토타입** | t_list *ft_lstlast(t_list *lst); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | lst: 리스트의 시작 노드. |
| **반환값** | 리스트의 마지막 노드. |
| **외부 함수 사용** | 없음 |
| **설명** | 리스트의 마지막 노드를 반환한다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_lstadd_back |
| :--------------: | :-----: |
| **프로토타입** | void ft_lstadd_back(t_list **lst, t_list *new); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | lst: 리스트의 첫 번째 링크의 포인터의 주소.<br>new: 리스트에 추가할 노드의 포인터의 주소. |
| **반환값** | 없음 |
| **외부 함수 사용** | 없음 |
| **설명** | 'new' 노드를 리스트의 끝에 추가한다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_lstdelone|
| :--------------: | :-----: |
| **프로토타입** | void ft_lstdelone(t_list *lst, void (*del)(void *));|
| **제출해야 하는 파일들** | - |
| **매개 변수** | lst: 해제 할 노드.<br>del: 내용을 삭제하는 데 사용되는 함수의 주소. |
| **반환값** | 없음 |
| **외부 함수 사용** | free |
| **설명** | 매개 변수로 노드를 받고 매개 변수로 주어진 'del' 함수를 사용하여 노드의 내용이 담긴 메모리를 해제하고 노드 자체도 해제 한다. 'next'의 메모리는 해제 되지 않는다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_lstclear |
| :--------------: | :-----: |
| **프로토타입** | void ft_lstclear(t_list **lst, void (*del)(void *)); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | lst: 노드의 포인터의 주소.<br>del: 노드의 내용을 삭제할 때 사용하는 함수의 주소. |
| **반환값** | 없음 |
| **외부 함수 사용** | free |
| **설명** | 'del' 함수와 free 함수를 사용하여 주어진 노드와 모든 일련의 노드들을 삭제하고 해제 한다.<br>마지막으로, 리스트의 포인터도 NULL로 설정해 줘야 한다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_lstiter |
| :--------------: | :-----: |
| **프로토타입** | void ft_lstiter(t_list *lst, void (*f)(void *)); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | lst: 노드의 포인터의 주소.<br>f: 리스트를 순회할 때 사용하는 함수의 주소. |
| **반환값** | 없음 |
| **외부 함수 사용** | 없음 |
| **설명** | 'lst' 리스트를 순회하고 각 노드의 내용에 'f' 함수를 적용한다. |

</div>
<br>

<div align="center">

| **함수 명** | ft_lstmap |
| :--------------: | :-----: |
| **프로토타입** | t_list *ft_lstmap(t_list *lst, void *(*f)(void *), void (*del)(void *)); |
| **제출해야 하는 파일들** | - |
| **매개 변수** | lst: 노드의 포인터의 주소.<br>f: 리스트를 순회할 때 사용하는 함수의 주소.<br>del: 필요한 경우 노드의 내용을 삭제하는 함수의 주소. |
| **반환값** | 새 리스트.<br>할당에 실패할 경우 NULL. |
| **외부 함수 사용** | malloc, free |
| **설명** | 'lst'를 순회하고 각 노드의 내용에 'f' 함수를 적용한다. 함수 'f'가 성공적으로 적용된 결과로 새 리스트를 만든다. 'del' 함수는 필요한 경우 노드의 내용을 삭제하는 데 사용한다. |

</div>
<br>
